//
//  pointer.c
//  demo
//
//  Created by vision chen on 2021/4/11.
//

#include "pointer.h"
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "swap.h"
#include "right_swap.h"
#include "arr_max.h"
#include "strlong.h"
#include "t_num_max.h"
#include <stdlib.h>
#define NULL ((void *)0)
void pointer(){
    int a = 10;
    char str[20] = "c.biancheng.net";
    printf("%#X,%#X\n",&a,str);
    // 数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
    // CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址
    // 假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算c = a + b;将会被转换成类似下面的形式
    // 0X3000 = (0X1000) + (0X2000);  ()表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存
    // 变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址
    // 在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量
    // 定义指针变量格式为: datatype *name; 或者 datatype *name = value;
    // *表示这是一个指针变量，datatype表示该指针变量所指向的数据的类型
    int *p_a = &a;
    printf("&a = %#X\n",*p_a);
    //在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址，a 前面必须要加取地址符&，否则是不对的
    // 和普通变量一样，指针变量也可以被多次写入
    float b = 99.5;
    p_a = &b;
    printf("&b = %#X\n",*p_a);
    p_a = &a;
    printf("&a = %#X\n",*p_a);
    // *是一个特殊符号，表明一个变量是指针变量,定义指针变量时必须带*，而给指针变量赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上*，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带*，给指针变量赋值时不能带*
    float c = 0.99;
    char d = '@';
    float *p2;
    char *p3;
    p2 = &c;
    p3 = &d;
    printf("&b = %#X,&c = %#X\n", p2, p3);
    //p2、p3 的类型分别是float*和char*，而不是float和char，它们是完全不同的数据类型
    // 指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为*pointer;
    printf("c = %f, d = %c\n",*p2,*p3);
    // 假设 a 的地址是 0X1000，p 指向 a 后，p 本身的值也会变为 0X1000，*p 表示获取地址 0X1000 上的数据，也即变量 a 的值。从运行结果看，*p 和 a 是等价的
    // CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过 *p 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”
    // 使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高
    // 指针除了可以获取内存上的数据，也可以修改内存上的数
    int e = 15, f = 99, g = 222;
    int *p6 = &e;
    *p6 = f; // 通过指针变量修改内存上的数据
    g = *p6; // 通过指针变量获取内存上的数据
    printf("%d,%d,%d,%d\n",e,f,g,*p6);
    // *在不同的场景下有不同的作用：*可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加*表示获取指针指向的数据，或者说表示的是指针指向的数据本身
    // 通过指针交换两个变量的值
    int k1 = 999, k2 = 100, temp;
    int *kp1 = &k1 , *kp2 = &k2;
    printf("k1 = %d, k2 = %d\n",k1,k2);
    /**开始交换**/
    temp = *kp1;
    *kp1 = *kp2;
    *kp2 = temp;
    /**交换结束**/
    printf("k1 = %d, k2 = %d\n",k1,k2);
    // 假设有一个 int 类型的变量 a，pa 是指向它的指针
    // *&a可以理解为*(&a)，&a表示取变量 a 的地址（等价于 pa），*(&a)表示取这个地址上的数据（等价于 *pa），绕来绕去，又回到了原点，*&a仍然等价于 a
    // &*pa可以理解为&(*pa)，*pa表示取得 pa 指向的数据（等价于 a），&(*pa)表示数据的地址（等价于 &a），所以&*pa等价于 pa
    
    //指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算
    int s = 12,*sa = &s,*ssa = &s;
    double y = 99.9, *sy = &y;
    char z = '&', *sz = &z;
    printf("&s=%#X,&y=%#X,&z=%#X\n",&s,&y,&z);
    printf("&sa=%#X,&sy=%#X,&sz=%#X\n",sa,sy,sz);
    sa++;sy++;sz++;
    printf("&sa=%#X,&sy=%#X,&sz=%#X\n",sa,sy,sz);
    sa -= 2 ; sy -= 2 ; sz -= 2;
    printf("&sa=%#X,&sy=%#X,&sz=%#X\n",sa,sy,sz);
    if (sa == ssa) {
        printf("sa == ssa,%d\n",*ssa);
    } else {
        printf("sa != ssa,%d\n",*sa);
    }
    // 引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针
    // 1. 使用下标
    // 也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]
    // 2. 使用指针
    // 也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)
    char str1[] = "https://baidu.com";
    char *pstr = str1;
    int len = strlen(str1),i;
    for ( i = 0; i < len; i++) {
        printf("%c",*(pstr + i));
    }
    printf("\n");
    for ( i = 0 ; i < len ; i++) {
        printf("%c",pstr[i]);
    }
    printf("\n");
    //除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串,str2指向首地址
    char *str2 = "http://dddd.com";
    // 改表示字符串的方法跟字符数组相似，但是也有区别
    // 它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限
    // 由于权限不同，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的
    // 使用字符数组还是字符串常量：在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量
    
    // 指针变量作为函数参数
    // 像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合
    // 有的时候，对于整数、小数、字符等基本类型数据的操作也必须要借助指针，一个典型的例子就是交换两个变量的值
    int aa = 66, bb = 99;
    swap(aa, bb);
    printf("aa = %d, bb = %d\n",aa,bb); // aa = 66, bb = 99
    // 可以看到aa和bb的值并没有交换，这是因为 swap() 函数内部的 a、b 和 main() 函数内部的 a、b 是不同的变量，占用不同的内存，它们除了名字一样，没有其他任何关系，swap() 交换的是它内部 a、b 的值，不会影响它外部
    // 要解决这个问题，可以使用指针变量作参数
    right_swap(&aa,&bb);
    printf("aa = %d, bb=%d\n",aa,bb); // aa = 99, bb=66
    // 数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。下面的例子定义了一个函数 arr_max()，用来查找数组中值最大的元素：
    int arr1[] = {2,21,432,2,1,76};
    int len1 = sizeof(arr1) / sizeof(int);
    printf("max number of arr is: %d\n",arr_max(arr1, len1));
    //不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度
    // C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针:参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上
    // 对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率
    
    // 指针作为函数返回值
    // 函数的返回值是一个指针（地址），我们将这样的函数称为指针函数
    // 函数 strlong()用来返回两个字符串中较长的一个
    char *str11 = "http://fasdfhasdffkjas.com";
    char *str22 = "https://afdfcjccfajf.com";
    char *str33 = strlong(str11, str22);
    printf("longer string is : %s\n",str33);
    // 用指针作为函数返回值时需要注意: 函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据
    
    // 二级指针
    // 如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针
    int aa1 = 1000;
    int *ps = &aa1;
    int **pss = &ps;
    int ***psss = &pss;
    printf("%d,%d,%d,%d\n",aa1,*ps,**pss,***psss);
    printf("&pss = %#X, psss = %#X\n",&pss,psss);
    printf("&ps = %#X, pss = %#X\n",&ps,pss);
    printf("&ps = %#X, pss = %#X, *psss = %#X\n",&ps,pss,*psss);
    printf("&a = %#X, ps = %#X, *pss = %#X, *psss = %#X \n",&aa1,ps,*pss,**psss);
    
    // 指针NULL以及void指针
    // 如果一个指针不指向任何数据，我们就称之为 空指针 ，用 NULL 表示
    int *p = NULL;  // NULL 是一个宏定义 注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符
    printf("p = %d\n",p);
    // 变量一旦定义就要分配内存，指针变量也是如此 int *p;  //它不是空指针 它的值是随机的，是垃圾值
    // p 经过定义，就一定在内存中分配了4个字节（32位环境）的空间，只是它的值是随机的，不像 int 会被初始化为 0，但是它确实指向了一段正常使用的内存。使用 p 时，操作的就是这段内存的数据，幸运的话能够正常运行，不过大部分情况下这段内存是无权操作的。
    //  注意 NULL 和 NUL 的区别：NULL表示空指针，是一个宏定义，可以在代码中直接使用。而 NUL 表示字符 '\0'，也就是字符串结束标志，它是ASCII码表中的第 0 个字符。NUL 没有在C语言中定义，仅仅是对 '\0' 的称呼，不能在代码中直接使用
    // void 指针类型，即可以定义一个指针变量，但不说明它指向哪一种类型数据
    void *pp = malloc(2); //在内存中分配2个字节的空间，但不确定它保存什么类型的数据
    // void 指针与空指针 NULL 不同：NULL 说明指针不指向任何数据，是“空的”；而 void 指针实实在在地指向一块内存，只是不知道这块内存中是什么类型的数据
    
    // 指针数组（数组每个元素都是指针）
    int aaa1 = 16 ,bb1 = 99,cc1 = 100;
    int *arr[3] = {&aaa1,&bb1,&cc1};
    int **parr = arr;
    printf("%d,%d,%d\n",*arr[0],*arr[1],*arr[2]);
    printf("%d,%d,%d\n",**(parr+0),**(parr+1),**(parr+2));
    //指针数组还可以和字符串数组结合使用
    //字符数组 str 中存放的是字符串的首地址，不是字符串本身，字符串本身位于其他的内存区域，和字符数组是分开的
    char *stra[3] = {
        "dff.language",
        "52pojie",
        "bilibili"
    };
    printf("%s\n%s\n%s\n",stra[0],stra[1],stra[2]);
    // 只有当指针数组中每个元素的类型都是char *时，才能像上面那样给指针数组赋值，其他类型不行
    
    // 二维数组指针
    // 二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的
    // 重要： C语言中的二维数组是按行排列的
    // 定义一个指向 a 的指针变量 p：int (*p)[4] = a;
    // 对指针进行加法（减法）运算时，它前进（后退）的步长与它指向的数据类型有关，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节，这正好是数组 a 所包含的每个一维数组的长度。也就是说，p+1会使得指针指向二维数组的下一行，p-1会使得指针指向数组的上一行
    // 数组名 a 在表达式中也会被转换为和 p 等价的指针！
    // 如何使用指针 p 来访问二维数组中的每个元素
    // 1. p指向数组 a 的开头，也即第 0 行；p+1前进一行，指向第 1 行。
    // 2. *(p+1)表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素
    // *(p+1)+1表示第 1 行第 1 个元素的地址
    int arr3[3][4] = {{1,3,5,2},{5,8,2,3},{4,23,12,52}};
    int (*app)[4] = arr3;
    printf("%d\n",sizeof(*(app+1)));
    // *(p+1)单独使用时表示的是第 1 行数据，放在表达式中会被转换为第 1 行数据的首地址，也就是第 1 行第 0 个元素的地址，因为使用整行数据没有实际的含义，编译器遇到这种情况都会转换为指向该行第 0 个元素的指针；
    // *(*(p+1)+1)表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据
    // 使用指针遍历二维数组
    int arr4[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    int (*mp)[4];
    int ip,jp;
    mp = arr4;
    for (ip = 0 ; ip < 3 ; ip++) {
        for (jp = 0 ; jp < 4; jp++) {
            printf("%2d ",*(*(mp+ip))+jp);
        }
        printf("\n");
    }
    // 指针数组和二维数组指针的区别
    // 指针数组和二维数组指针在定义时非常相似，只是括号的位置不同
//    int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
//    int (*p2)[5];  //二维数组指针，不能去掉括号
    // 指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存
    
    // 函数指针（指向函数的指针)
    // 一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。
    // 函数指针的定义形式 returnType (*pointerName)(param list);
    // returnType 为函数返回值类型，pointerName 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似
    // 注意( )的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为returnType *
    // 用指针来实现对函数的调用
    int (*pmax)(int,int) = t_num_max;
    printf("max value :%d\n",(*pmax)(54232,49235));
    // 指针：int *p   数组： int arr[10]   函数指针： int (* p)(int)
    //C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。从名字开始，不是从开头也不是从末尾
    // 它们的优先级从高到低依次是：() [] *(右结合性)
    // 前缀递增递减++p和*优先级相同，从右到左；
    // 后缀递增递减p++比前缀++p优先级高，从左到右。
    
    // 指针总结
    // nt *p;    p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。
//    int **p;    p 为二级指针，指向 int * 类型的数据。
//    int *p[n];    p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);
//    int (*p)[n];    p 为二维数组指针。
//    int *p();    p 是一个函数，它的返回值类型为 int *。
//    int (*p)();    p 是一个函数指针，指向原型为 int func() 的函数
    
    // 1. 指针变量可以进行加减运算，例如p++、p+i、p-=i。指针变量的加减运算并不是简单的加上或减去一个整数，而是跟指针指向的数据类型有关。
    // 2. 给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给一个整数，例如int *p = 1000;是没有意义的，使用过程中一般会导致程序崩溃。
    // 3. 使用指针变量之前一定要初始化，否则就不能确定指针指向哪里，如果它指向的内存没有使用权限，程序就崩溃了。对于暂时没有指向的指针，建议赋值NULL
    // 4.  两个指针变量可以相减。如果两个指针变量指向同一个数组中的某个元素，那么相减的结果就是两个指针之间相差的元素个数。
    // 5. 数组也是有类型的，数组名的本意是表示一组类型相同的数据。在定义数组时，或者和 sizeof、& 运算符一起使用时数组名才表示整个数组，表达式中的数组名会被转换为一个指向数组的指针
}
